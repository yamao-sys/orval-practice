/**
 * Generated by orval v7.9.0 🍺
 * Do not edit manually.
 * (title)
 * A sample service
 * OpenAPI spec version: 1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  DeleteTodo404,
  DeleteTodo500,
  DeleteTodoResponse,
  FetchTodosResponse,
  GetTodo404,
  GetTodo500,
  GetTodos500,
  PostTodos500,
  PutTodo404,
  PutTodo500,
  ShowTodoResponse,
  StoreTodoInput,
  StoreTodoResponse
} from '.././model';





/**
 * @summary Fetch Todos
 */
export type getTodosResponse200 = {
  data: FetchTodosResponse
  status: 200
}

export type getTodosResponse400 = {
  data: FetchTodosResponse
  status: 400
}

export type getTodosResponse500 = {
  data: GetTodos500
  status: 500
}
    
export type getTodosResponseComposite = getTodosResponse200 | getTodosResponse400 | getTodosResponse500;
    
export type getTodosResponse = getTodosResponseComposite & {
  headers: Headers;
}

export const getGetTodosUrl = () => {


  

  return `/todos/`
}

export const getTodos = async ( options?: RequestInit): Promise<getTodosResponse> => {
  
  const res = await fetch(getGetTodosUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getTodosResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getTodosResponse
}



export const getGetTodosQueryKey = () => {
    return [`/todos/`] as const;
    }

    
export const getGetTodosQueryOptions = <TData = Awaited<ReturnType<typeof getTodos>>, TError = FetchTodosResponse | GetTodos500>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getTodos>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTodosQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTodos>>> = ({ signal }) => getTodos({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTodos>>, TError, TData> & { queryKey: QueryKey }
}

export type GetTodosQueryResult = NonNullable<Awaited<ReturnType<typeof getTodos>>>
export type GetTodosQueryError = FetchTodosResponse | GetTodos500


/**
 * @summary Fetch Todos
 */

export function useGetTodos<TData = Awaited<ReturnType<typeof getTodos>>, TError = FetchTodosResponse | GetTodos500>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getTodos>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetTodosQueryOptions(options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Create Todo Schema
 */
export type postTodosResponse200 = {
  data: StoreTodoResponse
  status: 200
}

export type postTodosResponse400 = {
  data: StoreTodoResponse
  status: 400
}

export type postTodosResponse500 = {
  data: PostTodos500
  status: 500
}
    
export type postTodosResponseComposite = postTodosResponse200 | postTodosResponse400 | postTodosResponse500;
    
export type postTodosResponse = postTodosResponseComposite & {
  headers: Headers;
}

export const getPostTodosUrl = () => {


  

  return `/todos/`
}

export const postTodos = async (storeTodoInput: StoreTodoInput, options?: RequestInit): Promise<postTodosResponse> => {
  
  const res = await fetch(getPostTodosUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      storeTodoInput,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: postTodosResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as postTodosResponse
}




export const getPostTodosMutationOptions = <TError = StoreTodoResponse | PostTodos500,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postTodos>>, TError,{data: StoreTodoInput}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof postTodos>>, TError,{data: StoreTodoInput}, TContext> => {

const mutationKey = ['postTodos'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postTodos>>, {data: StoreTodoInput}> = (props) => {
          const {data} = props ?? {};

          return  postTodos(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostTodosMutationResult = NonNullable<Awaited<ReturnType<typeof postTodos>>>
    export type PostTodosMutationBody = StoreTodoInput
    export type PostTodosMutationError = StoreTodoResponse | PostTodos500

    /**
 * @summary Create Todo Schema
 */
export const usePostTodos = <TError = StoreTodoResponse | PostTodos500,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postTodos>>, TError,{data: StoreTodoInput}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof postTodos>>,
        TError,
        {data: StoreTodoInput},
        TContext
      > => {

      const mutationOptions = getPostTodosMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * @summary Show Todo
 */
export type getTodoResponse200 = {
  data: ShowTodoResponse
  status: 200
}

export type getTodoResponse404 = {
  data: GetTodo404
  status: 404
}

export type getTodoResponse500 = {
  data: GetTodo500
  status: 500
}
    
export type getTodoResponseComposite = getTodoResponse200 | getTodoResponse404 | getTodoResponse500;
    
export type getTodoResponse = getTodoResponseComposite & {
  headers: Headers;
}

export const getGetTodoUrl = (id: string,) => {


  

  return `/todos/${id}`
}

export const getTodo = async (id: string, options?: RequestInit): Promise<getTodoResponse> => {
  
  const res = await fetch(getGetTodoUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: getTodoResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as getTodoResponse
}



export const getGetTodoQueryKey = (id: string,) => {
    return [`/todos/${id}`] as const;
    }

    
export const getGetTodoQueryOptions = <TData = Awaited<ReturnType<typeof getTodo>>, TError = GetTodo404 | GetTodo500>(id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getTodo>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetTodoQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getTodo>>> = ({ signal }) => getTodo(id, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getTodo>>, TError, TData> & { queryKey: QueryKey }
}

export type GetTodoQueryResult = NonNullable<Awaited<ReturnType<typeof getTodo>>>
export type GetTodoQueryError = GetTodo404 | GetTodo500


/**
 * @summary Show Todo
 */

export function useGetTodo<TData = Awaited<ReturnType<typeof getTodo>>, TError = GetTodo404 | GetTodo500>(
 id: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof getTodo>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getGetTodoQueryOptions(id,options)

  const query = useQuery(queryOptions ) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}



/**
 * @summary Update Todo
 */
export type putTodoResponse200 = {
  data: StoreTodoResponse
  status: 200
}

export type putTodoResponse400 = {
  data: StoreTodoResponse
  status: 400
}

export type putTodoResponse404 = {
  data: PutTodo404
  status: 404
}

export type putTodoResponse500 = {
  data: PutTodo500
  status: 500
}
    
export type putTodoResponseComposite = putTodoResponse200 | putTodoResponse400 | putTodoResponse404 | putTodoResponse500;
    
export type putTodoResponse = putTodoResponseComposite & {
  headers: Headers;
}

export const getPutTodoUrl = (id: string,) => {


  

  return `/todos/${id}`
}

export const putTodo = async (id: string,
    storeTodoInput: StoreTodoInput, options?: RequestInit): Promise<putTodoResponse> => {
  
  const res = await fetch(getPutTodoUrl(id),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      storeTodoInput,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: putTodoResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as putTodoResponse
}




export const getPutTodoMutationOptions = <TError = StoreTodoResponse | PutTodo404 | PutTodo500,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putTodo>>, TError,{id: string;data: StoreTodoInput}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof putTodo>>, TError,{id: string;data: StoreTodoInput}, TContext> => {

const mutationKey = ['putTodo'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof putTodo>>, {id: string;data: StoreTodoInput}> = (props) => {
          const {id,data} = props ?? {};

          return  putTodo(id,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PutTodoMutationResult = NonNullable<Awaited<ReturnType<typeof putTodo>>>
    export type PutTodoMutationBody = StoreTodoInput
    export type PutTodoMutationError = StoreTodoResponse | PutTodo404 | PutTodo500

    /**
 * @summary Update Todo
 */
export const usePutTodo = <TError = StoreTodoResponse | PutTodo404 | PutTodo500,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof putTodo>>, TError,{id: string;data: StoreTodoInput}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof putTodo>>,
        TError,
        {id: string;data: StoreTodoInput},
        TContext
      > => {

      const mutationOptions = getPutTodoMutationOptions(options);

      return useMutation(mutationOptions );
    }
    /**
 * @summary Delete Todo
 */
export type deleteTodoResponse200 = {
  data: DeleteTodoResponse
  status: 200
}

export type deleteTodoResponse404 = {
  data: DeleteTodo404
  status: 404
}

export type deleteTodoResponse500 = {
  data: DeleteTodo500
  status: 500
}
    
export type deleteTodoResponseComposite = deleteTodoResponse200 | deleteTodoResponse404 | deleteTodoResponse500;
    
export type deleteTodoResponse = deleteTodoResponseComposite & {
  headers: Headers;
}

export const getDeleteTodoUrl = (id: string,) => {


  

  return `/todos/${id}`
}

export const deleteTodo = async (id: string, options?: RequestInit): Promise<deleteTodoResponse> => {
  
  const res = await fetch(getDeleteTodoUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: deleteTodoResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as deleteTodoResponse
}




export const getDeleteTodoMutationOptions = <TError = DeleteTodo404 | DeleteTodo500,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteTodo>>, TError,{id: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deleteTodo>>, TError,{id: string}, TContext> => {

const mutationKey = ['deleteTodo'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteTodo>>, {id: string}> = (props) => {
          const {id} = props ?? {};

          return  deleteTodo(id,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteTodoMutationResult = NonNullable<Awaited<ReturnType<typeof deleteTodo>>>
    
    export type DeleteTodoMutationError = DeleteTodo404 | DeleteTodo500

    /**
 * @summary Delete Todo
 */
export const useDeleteTodo = <TError = DeleteTodo404 | DeleteTodo500,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteTodo>>, TError,{id: string}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deleteTodo>>,
        TError,
        {id: string},
        TContext
      > => {

      const mutationOptions = getDeleteTodoMutationOptions(options);

      return useMutation(mutationOptions );
    }
    